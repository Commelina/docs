{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to HStreamDB \u00b6 What is HStreamDB? \u00b6 HStreamDB is a streaming database built for streaming data storage and real time streaming processing. Why use HStreamDB? \u00b6 Nowadays data is constantly being generated from different sources, e.g. sensor data from the IoT, user click events on the Internet, etc... We want to build low-latency applications that respond quickly to these incoming streaming data to deliver better user experience, real-time data insights and timely business decisions. But currently building such stream processing applications is not easy, you always need to combine multiple independent components to construct a basic stream processing architecture. For example, you need at least a streaming data capture subsystem, a message/event storage component, a stream processing engine, and multiple derived data systems for different query needs. Obviously all of this shouldn't be so complicated, which is why HStreamDB comes into play. Just as you can easily build a simple CRUD application based on a traditional database, with HStreamDB you can easily build a basic streaming application without any other dependencies.","title":"Home"},{"location":"#welcome-to-hstreamdb","text":"","title":"Welcome to HStreamDB"},{"location":"#what-is-hstreamdb","text":"HStreamDB is a streaming database built for streaming data storage and real time streaming processing.","title":"What is HStreamDB?"},{"location":"#why-use-hstreamdb","text":"Nowadays data is constantly being generated from different sources, e.g. sensor data from the IoT, user click events on the Internet, etc... We want to build low-latency applications that respond quickly to these incoming streaming data to deliver better user experience, real-time data insights and timely business decisions. But currently building such stream processing applications is not easy, you always need to combine multiple independent components to construct a basic stream processing architecture. For example, you need at least a streaming data capture subsystem, a message/event storage component, a stream processing engine, and multiple derived data systems for different query needs. Obviously all of this shouldn't be so complicated, which is why HStreamDB comes into play. Just as you can easily build a simple CRUD application based on a traditional database, with HStreamDB you can easily build a basic streaming application without any other dependencies.","title":"Why use HStreamDB?"},{"location":"development/build-from-source/","text":"Building from source \u00b6 This document describes how to build HStreamDB from source code. Install rocksdb \u00b6 TODO Building with cabal \u00b6 TODO Building with stack \u00b6 TODO","title":"Building from source"},{"location":"development/build-from-source/#building-from-source","text":"This document describes how to build HStreamDB from source code.","title":"Building from source"},{"location":"development/build-from-source/#install-rocksdb","text":"TODO","title":"Install rocksdb"},{"location":"development/build-from-source/#building-with-cabal","text":"TODO","title":"Building with cabal"},{"location":"development/build-from-source/#building-with-stack","text":"TODO","title":"Building with stack"},{"location":"development/haskell-style/","text":"Haskell Style Guide \u00b6 This document is a slightly modified version of style guide used in Kowainik . Style guide goals \u00b6 The purpose of this document is to help developers and people working on Haskell code-bases to have a smoother experience while dealing with code in different situations. This style guide aims to increase productivity by defining the following goals: Make code easier to understand: ideas for solutions should not be hidden behind complex and obscure code. Make code easier to read: code arrangement should be immediately apparent after looking at the existing code. Names of functions & variables should be transparent and obvious. Make code easier to write: developers should think about code formatting rules as little as possible. The style guide should answer any query pertaining to the formatting of a specific piece of code. Make code easier to maintain: this style guide aims to reduce the burden of maintaining packages using version control systems unless this conflicts with the previous points. Rule of thumb when working with existing source code The general rule is to stick to the same coding style that is already used in the file you are editing. If you must make significant style modifications, then commit them independently from the functional changes so that someone looking back through the changelog can easily distinguish between them. Indentation \u00b6 Indent code blocks with 2 spaces . Always put a where keyword on a new line. showSign :: Int -> String showSign n | n == 0 = \"Zero\" | n < 0 = \"Negative\" | otherwise = \"Positive\" greet :: IO () greet = do putStrLn \"What is your name?\" name <- getLine putStrLn $ greeting name where greeting :: String -> String greeting name = \"Hey \" ++ name ++ \"!\" Line length \u00b6 The maximum preferred line length is 80 characters . Tip There is no hard rules when it comes to line length. Some lines just have to be a bit longer than usual. However, if your line of code exceeds this limit, try to split code into smaller chunks or break long lines over multiple shorter ones as much as you can. Whitespaces \u00b6 No trailing whitespaces (use some tools to automatically cleanup trailing whitespaces). Surround binary operators with a single space on either side. Alignment \u00b6 Use comma-leading style for formatting module exports, lists, tuples, records, etc. answers :: [ Maybe Int ] answers = [ Just 42 , Just 7 , Nothing ] If a function definition doesn't fit the line limit then align multiple lines according to the same separator like :: , => , -> . -- + Good printQuestion :: Show a => Text -- ^ Question text -> [ a ] -- ^ List of available answers -> IO () -- + Acceptable if function name is short fun :: Show a => Text -- ^ Question text -> [ a ] -- ^ List of available answers -> IO () Align records with every field on a separate line with leading commas. -- + Good data Foo = Foo { fooBar :: Bar , fooBaz :: Baz , fooQuux :: Quux } deriving ( Eq , Show , Generic ) deriving anyclass ( FromJSON , ToJSON ) -- + Acceptable data Foo = Foo { fooBar :: Bar , fooBaz :: Baz , fooQuux :: Quux } deriving ( Eq , Show , Generic ) deriving anyclass ( FromJSON , ToJSON ) Align sum types with every constructor on its own line with leading = and | . -- + Good data TrafficLight = Red | Yellow | Green deriving ( Eq , Ord , Enum , Bounded , Show , Read ) -- + Acceptable data TrafficLight = Red | Yellow | Green deriving ( Eq , Ord , Enum , Bounded , Show , Read ) Try to follow the above rule inside function definitions but without fanatism: -- + Good createFoo = Foo <$> veryLongBar <*> veryLongBaz -- + Acceptable createFoo = Foo <$> veryLongBar <*> veryLongBaz -- + Acceptable createFoo = Foo <$> veryLongBar <*> veryLongBaz -- - Bad createFoo = Foo <$> veryLongBar <*> veryLongBaz -- - Bad createFoo = Foo -- there's no need to put the constructor on a separate line and have an extra line <$> veryLongBar <*> veryLongBaz Basically, it is often possible to join consequent lines without introducing alignment dependency. Try not to span multiple short lines unnecessarily. If a function application must spawn multiple lines to fit within the maximum line length, then write one argument on each line following the head, indented by one level: veryLongProductionName firstArgumentOfThisFunction secondArgumentOfThisFunction ( DummyDatatype withDummyField1 andDummyField2 ) lastArgumentOfThisFunction Naming \u00b6 Functions and variables \u00b6 lowerCamelCase for function and variable names. UpperCamelCase for data types, typeclasses and constructors. Variant Use ids_with_underscores for local variables only. Try not to create new operators. -- What does this 'mouse operator' mean? :thinking_suicide: ( ~@@^> ) :: Functor f => ( a -> b ) -> ( a -> c -> d ) -> ( b -> f c ) -> a -> f d Do not use ultra-short or indescriptive names like a , par , g unless the types of these variables are general enough. -- + Good mapSelect :: forall a . ( a -> Bool ) -> ( a -> a ) -> ( a -> a ) -> [ a ] -> [ a ] mapSelect test ifTrue ifFalse = go where go :: [ a ] -> [ a ] go [] = [] go ( x : xs ) = if test x then ifTrue x : go xs else ifFalse x : go xs -- - Bad mapSelect :: forall a . ( a -> Bool ) -> ( a -> a ) -> ( a -> a ) -> [ a ] -> [ a ] mapSelect p f g = go where go :: [ a ] -> [ a ] go [] = [] go ( x : xs ) = if p x then f x : go xs else g x : go xs Do not introduce unnecessarily long names for variables. -- + Good map :: ( a -> b ) -> [ a ] -> [ b ] map _ [] = [] map f ( x : xs ) = f x : map f xs -- - Bad map :: ( a -> b ) -> [ a ] -> [ b ] map _ [] = [] map function ( firstElement : remainingList ) = function firstElement : map function remainingList For readability reasons, do not capitalize all letters when using an abbreviation as a part of a longer name. For example, write TomlException instead of TOMLException . Unicode symbols are allowed only in modules that already use unicode symbols. If you create a unicode name, you should also create a non-unicode one as an alias. Data types \u00b6 Creating data types is extremely easy in Haskell. It is usually a good idea to introduce a custom data type (enum or newtype ) instead of using a commonly used data type (like Int , String , Set Text , etc.). type aliases are allowed only for specializing general types: -- + Good data StateT s m a type State s = StateT s Identity -- - Bad type Size = Int Use the data type name as the constructor name for data with single constructor and newtype . data User = User Int String The field name for a newtype must be prefixed by un followed by the type name. newtype Size = Size { unSize :: Int } newtype App a = App { unApp :: ReaderT Context IO a } Field names for the record data type should start with the full name of the data type. -- + Good data HealthReading = HealthReading { healthReadingDate :: UTCTime , healthReadingMeasurement :: Double } It is acceptable to use an abbreviation as the field prefix if the data type name is too long. -- + Acceptable data HealthReading = HealthReading { hrDate :: UTCTime , hrMeasurement :: Double } Comments \u00b6 Separate end-of-line comments from the code with 2 spaces . newtype Measure = Measure { unMeasure :: Double -- ^ See how 2 spaces separate this comment } Write Haddock documentation for the top-level functions, function arguments and data type fields. The documentation should give enough information to apply the function without looking at its definition. -- | Single-line short comment. foo :: Int -> [ a ] -> [ a ] -- | Example of multi-line block comment which is very long -- and doesn't fit single line. foo :: Int -> [ a ] -> [ a ] -- + Good -- | 'replicate' @n x@ returns list of length @n@ with @x@ as the value of -- every element. This function is lazy in its returned value. replicate :: Int -- ^ Length of returned list -> a -- ^ Element to populate list -> [ a ] -- - Bad -- | 'replicate' @n x@ returns list of length @n@ with @x@ as the value of -- every element. This function is lazy in its returned value. replicate :: Int -- ^ Length of returned list {- | Element to populate list -} -> a -> [ a ] If possible, include typeclass laws and function usage examples into the documentation. -- | The class of semigroups (types with an associative binary operation). -- -- Instances should satisfy the associativity law: -- -- * @x '<>' (y '<>' z) = (x '<>' y) '<>' z@ class Semigroup a where ( <> ) :: a -> a -> a -- | The 'intersperse' function takes a character and places it -- between the characters of a 'Text'. -- -- >>> T.intersperse '.' \"SHIELD\" -- \"S.H.I.E.L.D\" intersperse :: Char -> Text -> Text Guideline for module formatting \u00b6 Allowed tools for automatic module formatting: stylish-haskell : for formatting the import section and for alignment. LANGUAGE \u00b6 Put OPTIONS_GHC pragma before LANGUAGE pragmas in a separate section. Write each LANGUAGE pragma on its own line, sort them alphabetically and align by max width among them. {-# OPTIONS_GHC -fno-warn-orphans #-} {-# LANGUAGE ApplicativeDo #-} {-# LANGUAGE ScopedTypeVariables #-} {-# LANGUAGE TypeApplications #-} Always put language extensions in the relevant source file. Tip Language extensions must be listed at the very top of the file, above the module name. Export lists \u00b6 Use the following rules to format the export section: Always write an explicit export list. Indent the export list by 2 spaces . You can split the export list into sections. Use Haddock to assign names to these sections. Classes, data types and type aliases should be written before functions in each section. module Map ( -- * Data type Map , Key , empty -- * Update , insert , insertWith , alter ) where Imports \u00b6 Always use explicit import lists or qualified imports. Use qualified imports only if the import list is big enough or there are conflicts in names. This makes the code more robust against changes in dependent libraries. Exception: modules that only reexport other entire modules. Imports should be grouped in the following order: Imports from Hackage packages. Imports from the current project. Put a blank line between each group of imports. The imports in each group should be sorted alphabetically by module name. module MyProject.Foo ( Foo ( .. ) ) where import Control.Exception ( catch , try ) import qualified Data.Aeson as Json import qualified Data.Text as Text import Data.Traversable ( for ) import MyProject.Ansi ( errorMessage , infoMessage ) import qualified MyProject.BigModule as Big data Foo ... Data declaration \u00b6 Refer to the Alignment section to see how to format data type declarations. Records for data types with multiple constructors are forbidden. -- - Bad data Foo = Bar { bar1 :: Int , bar2 :: Double } | Baz { baz1 :: Int , baz2 :: Double , baz3 :: Text } -- + Good data Foo = FooBar Bar | FooBaz Baz data Bar = Bar { bar1 :: Int , bar2 :: Double } data Baz = Baz { baz1 :: Int , baz2 :: Double , baz3 :: Text } -- + Also good data Foo = Bar Int Double | Baz Int Double Text Strictness \u00b6 Fields of data type constructors should be strict. Specify strictness explicitly with ! . This helps to avoid space leaks and gives you an error instead of a warning in case you forget to initialize some fields. -- + Good data Settings = Settings { settingsHasTravis :: ! Bool , settingsConfigPath :: ! FilePath , settingsRetryCount :: ! Int } -- - Bad data Settings = Settings { settingsHasTravis :: Bool , settingsConfigPath :: FilePath , settingsRetryCount :: Int } Deriving \u00b6 Type classes in the deriving section should always be surrounded by parentheses. Don't derive typeclasses unnecessarily. Use -XDerivingStrategies extension for newtype s to explicitly specify the way you want to derive type classes: {-# LANGUAGE DeriveAnyClass #-} {-# LANGUAGE DerivingStrategies #-} {-# LANGUAGE GeneralizedNewtypeDeriving #-} newtype Id a = Id { unId :: Int } deriving stock ( Generic ) deriving newtype ( Eq , Ord , Show , Hashable ) deriving anyclass ( FromJSON , ToJSON ) Function declaration \u00b6 All top-level functions must have type signatures. All functions inside a where block must have type signatures. Explicit type signatures help to avoid cryptic type errors. You might need the -XScopedTypeVariables extension to write the polymorphic types of functions inside a where block. Surround . after forall in type signatures with spaces. lookup :: forall a f . Typeable a => TypeRepMap f -> Maybe ( f a ) If the function type signature is very long, then place the type of each argument under its own line with respect to alignment. sendEmail :: forall env m . ( MonadLog m , MonadEmail m , WithDb env m ) => Email -> Subject -> Body -> Template -> m () If the line with argument names is too big, then put each argument on its own line and separate it somehow from the body section. sendEmail toEmail subject @ ( Subject subj ) body Template { .. } -- default body variables = do < code goes here > In other cases, place an = sign on the same line where the function definition is. Put operator fixity before operator signature: -- | Flipped version of '<$>'. infixl 1 <&> ( <&> ) :: Functor f => f a -> ( a -> b ) -> f b as <&> f = f <$> as Put pragmas immediately following the function they apply to. -- | Lifted version of 'T.putStrLn'. putTextLn :: MonadIO m => Text -> m () putTextLn = liftIO . Text . putStrLn {-# INLINE putTextLn #-} {-# SPECIALIZE putTextLn :: Text -> IO () #-} In case of data type definitions, you must put the pragma before the type it applies to. Example: data TypeRepMap ( f :: k -> Type ) = TypeRepMap { fingerprintAs :: {-# UNPACK #-} ! ( PrimArray Word64 ) , fingerprintBs :: {-# UNPACK #-} ! ( PrimArray Word64 ) , trAnys :: {-# UNPACK #-} ! ( Array Any ) , trKeys :: {-# UNPACK #-} ! ( Array Any ) } if-then-else clauses \u00b6 Prefer guards over if-then-else where possible. -- + Good showParity :: Int -> Bool showParity n | even n = \"even\" | otherwise = \"odd\" -- - Meh showParity :: Int -> Bool showParity n = if even n then \"even\" else \"odd\" In the code outside do -blocks you can align if-then-else clauses like you would normal expressions: shiftInts :: [ Int ] -> [ Int ] shiftInts = map $ \\ n -> if even n then n + 1 else n - 1 Case expressions \u00b6 Align the -> arrows in the alternatives when it helps readability. -- + Good firstOrDefault :: [ a ] -> a -> a firstOrDefault list def = case list of [] -> def x : _ -> x -- - Bad foo :: IO () foo = getArgs >>= \\ case [] -> do putStrLn \"No arguments provided\" runWithNoArgs firstArg : secondArg : rest -> do putStrLn $ \"The first argument is \" ++ firstArg putStrLn $ \"The second argument is \" ++ secondArg _ -> pure () Use the -XLambdaCase extension when you perform pattern matching over the last argument of the function: fromMaybe :: a -> Maybe a -> a fromMaybe v = \\ case Nothing -> v Just x -> x let expressions \u00b6 Write every let -binding on a new line: isLimitedBy :: Integer -> Natural -> Bool isLimitedBy n limit = let intLimit = toInteger limit in n <= intLimit Put a let before each variable inside a do block. General recommendations \u00b6 Try to split code into separate modules. Avoid abusing point-free style. Sometimes code is clearer when not written in point-free style: -- + Good foo :: Int -> a -> Int foo n x = length $ replicate n x -- - Bad foo :: Int -> a -> Int foo = ( length . ) . replicate Code should be compilable with the following ghc options without warnings: -Wall -Wincomplete-uni-patterns -Wincomplete-record-updates -Wcompat -Widentities -Wredundant-constraints -Wmissing-export-lists -Wpartial-fields Enable -fhide-source-paths and -freverse-errors for cleaner compiler output. Use -XApplicativeDo in combination with -XRecordWildCards to prevent position-sensitive errors where possible.","title":"Haskell style"},{"location":"development/haskell-style/#haskell-style-guide","text":"This document is a slightly modified version of style guide used in Kowainik .","title":"Haskell Style Guide"},{"location":"development/haskell-style/#style-guide-goals","text":"The purpose of this document is to help developers and people working on Haskell code-bases to have a smoother experience while dealing with code in different situations. This style guide aims to increase productivity by defining the following goals: Make code easier to understand: ideas for solutions should not be hidden behind complex and obscure code. Make code easier to read: code arrangement should be immediately apparent after looking at the existing code. Names of functions & variables should be transparent and obvious. Make code easier to write: developers should think about code formatting rules as little as possible. The style guide should answer any query pertaining to the formatting of a specific piece of code. Make code easier to maintain: this style guide aims to reduce the burden of maintaining packages using version control systems unless this conflicts with the previous points. Rule of thumb when working with existing source code The general rule is to stick to the same coding style that is already used in the file you are editing. If you must make significant style modifications, then commit them independently from the functional changes so that someone looking back through the changelog can easily distinguish between them.","title":"Style guide goals"},{"location":"development/haskell-style/#indentation","text":"Indent code blocks with 2 spaces . Always put a where keyword on a new line. showSign :: Int -> String showSign n | n == 0 = \"Zero\" | n < 0 = \"Negative\" | otherwise = \"Positive\" greet :: IO () greet = do putStrLn \"What is your name?\" name <- getLine putStrLn $ greeting name where greeting :: String -> String greeting name = \"Hey \" ++ name ++ \"!\"","title":"Indentation"},{"location":"development/haskell-style/#line-length","text":"The maximum preferred line length is 80 characters . Tip There is no hard rules when it comes to line length. Some lines just have to be a bit longer than usual. However, if your line of code exceeds this limit, try to split code into smaller chunks or break long lines over multiple shorter ones as much as you can.","title":"Line length"},{"location":"development/haskell-style/#whitespaces","text":"No trailing whitespaces (use some tools to automatically cleanup trailing whitespaces). Surround binary operators with a single space on either side.","title":"Whitespaces"},{"location":"development/haskell-style/#alignment","text":"Use comma-leading style for formatting module exports, lists, tuples, records, etc. answers :: [ Maybe Int ] answers = [ Just 42 , Just 7 , Nothing ] If a function definition doesn't fit the line limit then align multiple lines according to the same separator like :: , => , -> . -- + Good printQuestion :: Show a => Text -- ^ Question text -> [ a ] -- ^ List of available answers -> IO () -- + Acceptable if function name is short fun :: Show a => Text -- ^ Question text -> [ a ] -- ^ List of available answers -> IO () Align records with every field on a separate line with leading commas. -- + Good data Foo = Foo { fooBar :: Bar , fooBaz :: Baz , fooQuux :: Quux } deriving ( Eq , Show , Generic ) deriving anyclass ( FromJSON , ToJSON ) -- + Acceptable data Foo = Foo { fooBar :: Bar , fooBaz :: Baz , fooQuux :: Quux } deriving ( Eq , Show , Generic ) deriving anyclass ( FromJSON , ToJSON ) Align sum types with every constructor on its own line with leading = and | . -- + Good data TrafficLight = Red | Yellow | Green deriving ( Eq , Ord , Enum , Bounded , Show , Read ) -- + Acceptable data TrafficLight = Red | Yellow | Green deriving ( Eq , Ord , Enum , Bounded , Show , Read ) Try to follow the above rule inside function definitions but without fanatism: -- + Good createFoo = Foo <$> veryLongBar <*> veryLongBaz -- + Acceptable createFoo = Foo <$> veryLongBar <*> veryLongBaz -- + Acceptable createFoo = Foo <$> veryLongBar <*> veryLongBaz -- - Bad createFoo = Foo <$> veryLongBar <*> veryLongBaz -- - Bad createFoo = Foo -- there's no need to put the constructor on a separate line and have an extra line <$> veryLongBar <*> veryLongBaz Basically, it is often possible to join consequent lines without introducing alignment dependency. Try not to span multiple short lines unnecessarily. If a function application must spawn multiple lines to fit within the maximum line length, then write one argument on each line following the head, indented by one level: veryLongProductionName firstArgumentOfThisFunction secondArgumentOfThisFunction ( DummyDatatype withDummyField1 andDummyField2 ) lastArgumentOfThisFunction","title":"Alignment"},{"location":"development/haskell-style/#naming","text":"","title":"Naming"},{"location":"development/haskell-style/#functions-and-variables","text":"lowerCamelCase for function and variable names. UpperCamelCase for data types, typeclasses and constructors. Variant Use ids_with_underscores for local variables only. Try not to create new operators. -- What does this 'mouse operator' mean? :thinking_suicide: ( ~@@^> ) :: Functor f => ( a -> b ) -> ( a -> c -> d ) -> ( b -> f c ) -> a -> f d Do not use ultra-short or indescriptive names like a , par , g unless the types of these variables are general enough. -- + Good mapSelect :: forall a . ( a -> Bool ) -> ( a -> a ) -> ( a -> a ) -> [ a ] -> [ a ] mapSelect test ifTrue ifFalse = go where go :: [ a ] -> [ a ] go [] = [] go ( x : xs ) = if test x then ifTrue x : go xs else ifFalse x : go xs -- - Bad mapSelect :: forall a . ( a -> Bool ) -> ( a -> a ) -> ( a -> a ) -> [ a ] -> [ a ] mapSelect p f g = go where go :: [ a ] -> [ a ] go [] = [] go ( x : xs ) = if p x then f x : go xs else g x : go xs Do not introduce unnecessarily long names for variables. -- + Good map :: ( a -> b ) -> [ a ] -> [ b ] map _ [] = [] map f ( x : xs ) = f x : map f xs -- - Bad map :: ( a -> b ) -> [ a ] -> [ b ] map _ [] = [] map function ( firstElement : remainingList ) = function firstElement : map function remainingList For readability reasons, do not capitalize all letters when using an abbreviation as a part of a longer name. For example, write TomlException instead of TOMLException . Unicode symbols are allowed only in modules that already use unicode symbols. If you create a unicode name, you should also create a non-unicode one as an alias.","title":"Functions and variables"},{"location":"development/haskell-style/#data-types","text":"Creating data types is extremely easy in Haskell. It is usually a good idea to introduce a custom data type (enum or newtype ) instead of using a commonly used data type (like Int , String , Set Text , etc.). type aliases are allowed only for specializing general types: -- + Good data StateT s m a type State s = StateT s Identity -- - Bad type Size = Int Use the data type name as the constructor name for data with single constructor and newtype . data User = User Int String The field name for a newtype must be prefixed by un followed by the type name. newtype Size = Size { unSize :: Int } newtype App a = App { unApp :: ReaderT Context IO a } Field names for the record data type should start with the full name of the data type. -- + Good data HealthReading = HealthReading { healthReadingDate :: UTCTime , healthReadingMeasurement :: Double } It is acceptable to use an abbreviation as the field prefix if the data type name is too long. -- + Acceptable data HealthReading = HealthReading { hrDate :: UTCTime , hrMeasurement :: Double }","title":"Data types"},{"location":"development/haskell-style/#comments","text":"Separate end-of-line comments from the code with 2 spaces . newtype Measure = Measure { unMeasure :: Double -- ^ See how 2 spaces separate this comment } Write Haddock documentation for the top-level functions, function arguments and data type fields. The documentation should give enough information to apply the function without looking at its definition. -- | Single-line short comment. foo :: Int -> [ a ] -> [ a ] -- | Example of multi-line block comment which is very long -- and doesn't fit single line. foo :: Int -> [ a ] -> [ a ] -- + Good -- | 'replicate' @n x@ returns list of length @n@ with @x@ as the value of -- every element. This function is lazy in its returned value. replicate :: Int -- ^ Length of returned list -> a -- ^ Element to populate list -> [ a ] -- - Bad -- | 'replicate' @n x@ returns list of length @n@ with @x@ as the value of -- every element. This function is lazy in its returned value. replicate :: Int -- ^ Length of returned list {- | Element to populate list -} -> a -> [ a ] If possible, include typeclass laws and function usage examples into the documentation. -- | The class of semigroups (types with an associative binary operation). -- -- Instances should satisfy the associativity law: -- -- * @x '<>' (y '<>' z) = (x '<>' y) '<>' z@ class Semigroup a where ( <> ) :: a -> a -> a -- | The 'intersperse' function takes a character and places it -- between the characters of a 'Text'. -- -- >>> T.intersperse '.' \"SHIELD\" -- \"S.H.I.E.L.D\" intersperse :: Char -> Text -> Text","title":"Comments"},{"location":"development/haskell-style/#guideline-for-module-formatting","text":"Allowed tools for automatic module formatting: stylish-haskell : for formatting the import section and for alignment.","title":"Guideline for module formatting"},{"location":"development/haskell-style/#language","text":"Put OPTIONS_GHC pragma before LANGUAGE pragmas in a separate section. Write each LANGUAGE pragma on its own line, sort them alphabetically and align by max width among them. {-# OPTIONS_GHC -fno-warn-orphans #-} {-# LANGUAGE ApplicativeDo #-} {-# LANGUAGE ScopedTypeVariables #-} {-# LANGUAGE TypeApplications #-} Always put language extensions in the relevant source file. Tip Language extensions must be listed at the very top of the file, above the module name.","title":"LANGUAGE"},{"location":"development/haskell-style/#export-lists","text":"Use the following rules to format the export section: Always write an explicit export list. Indent the export list by 2 spaces . You can split the export list into sections. Use Haddock to assign names to these sections. Classes, data types and type aliases should be written before functions in each section. module Map ( -- * Data type Map , Key , empty -- * Update , insert , insertWith , alter ) where","title":"Export lists"},{"location":"development/haskell-style/#imports","text":"Always use explicit import lists or qualified imports. Use qualified imports only if the import list is big enough or there are conflicts in names. This makes the code more robust against changes in dependent libraries. Exception: modules that only reexport other entire modules. Imports should be grouped in the following order: Imports from Hackage packages. Imports from the current project. Put a blank line between each group of imports. The imports in each group should be sorted alphabetically by module name. module MyProject.Foo ( Foo ( .. ) ) where import Control.Exception ( catch , try ) import qualified Data.Aeson as Json import qualified Data.Text as Text import Data.Traversable ( for ) import MyProject.Ansi ( errorMessage , infoMessage ) import qualified MyProject.BigModule as Big data Foo ...","title":"Imports"},{"location":"development/haskell-style/#data-declaration","text":"Refer to the Alignment section to see how to format data type declarations. Records for data types with multiple constructors are forbidden. -- - Bad data Foo = Bar { bar1 :: Int , bar2 :: Double } | Baz { baz1 :: Int , baz2 :: Double , baz3 :: Text } -- + Good data Foo = FooBar Bar | FooBaz Baz data Bar = Bar { bar1 :: Int , bar2 :: Double } data Baz = Baz { baz1 :: Int , baz2 :: Double , baz3 :: Text } -- + Also good data Foo = Bar Int Double | Baz Int Double Text","title":"Data declaration"},{"location":"development/haskell-style/#strictness","text":"Fields of data type constructors should be strict. Specify strictness explicitly with ! . This helps to avoid space leaks and gives you an error instead of a warning in case you forget to initialize some fields. -- + Good data Settings = Settings { settingsHasTravis :: ! Bool , settingsConfigPath :: ! FilePath , settingsRetryCount :: ! Int } -- - Bad data Settings = Settings { settingsHasTravis :: Bool , settingsConfigPath :: FilePath , settingsRetryCount :: Int }","title":"Strictness"},{"location":"development/haskell-style/#deriving","text":"Type classes in the deriving section should always be surrounded by parentheses. Don't derive typeclasses unnecessarily. Use -XDerivingStrategies extension for newtype s to explicitly specify the way you want to derive type classes: {-# LANGUAGE DeriveAnyClass #-} {-# LANGUAGE DerivingStrategies #-} {-# LANGUAGE GeneralizedNewtypeDeriving #-} newtype Id a = Id { unId :: Int } deriving stock ( Generic ) deriving newtype ( Eq , Ord , Show , Hashable ) deriving anyclass ( FromJSON , ToJSON )","title":"Deriving"},{"location":"development/haskell-style/#function-declaration","text":"All top-level functions must have type signatures. All functions inside a where block must have type signatures. Explicit type signatures help to avoid cryptic type errors. You might need the -XScopedTypeVariables extension to write the polymorphic types of functions inside a where block. Surround . after forall in type signatures with spaces. lookup :: forall a f . Typeable a => TypeRepMap f -> Maybe ( f a ) If the function type signature is very long, then place the type of each argument under its own line with respect to alignment. sendEmail :: forall env m . ( MonadLog m , MonadEmail m , WithDb env m ) => Email -> Subject -> Body -> Template -> m () If the line with argument names is too big, then put each argument on its own line and separate it somehow from the body section. sendEmail toEmail subject @ ( Subject subj ) body Template { .. } -- default body variables = do < code goes here > In other cases, place an = sign on the same line where the function definition is. Put operator fixity before operator signature: -- | Flipped version of '<$>'. infixl 1 <&> ( <&> ) :: Functor f => f a -> ( a -> b ) -> f b as <&> f = f <$> as Put pragmas immediately following the function they apply to. -- | Lifted version of 'T.putStrLn'. putTextLn :: MonadIO m => Text -> m () putTextLn = liftIO . Text . putStrLn {-# INLINE putTextLn #-} {-# SPECIALIZE putTextLn :: Text -> IO () #-} In case of data type definitions, you must put the pragma before the type it applies to. Example: data TypeRepMap ( f :: k -> Type ) = TypeRepMap { fingerprintAs :: {-# UNPACK #-} ! ( PrimArray Word64 ) , fingerprintBs :: {-# UNPACK #-} ! ( PrimArray Word64 ) , trAnys :: {-# UNPACK #-} ! ( Array Any ) , trKeys :: {-# UNPACK #-} ! ( Array Any ) }","title":"Function declaration"},{"location":"development/haskell-style/#if-then-else-clauses","text":"Prefer guards over if-then-else where possible. -- + Good showParity :: Int -> Bool showParity n | even n = \"even\" | otherwise = \"odd\" -- - Meh showParity :: Int -> Bool showParity n = if even n then \"even\" else \"odd\" In the code outside do -blocks you can align if-then-else clauses like you would normal expressions: shiftInts :: [ Int ] -> [ Int ] shiftInts = map $ \\ n -> if even n then n + 1 else n - 1","title":"if-then-else clauses"},{"location":"development/haskell-style/#case-expressions","text":"Align the -> arrows in the alternatives when it helps readability. -- + Good firstOrDefault :: [ a ] -> a -> a firstOrDefault list def = case list of [] -> def x : _ -> x -- - Bad foo :: IO () foo = getArgs >>= \\ case [] -> do putStrLn \"No arguments provided\" runWithNoArgs firstArg : secondArg : rest -> do putStrLn $ \"The first argument is \" ++ firstArg putStrLn $ \"The second argument is \" ++ secondArg _ -> pure () Use the -XLambdaCase extension when you perform pattern matching over the last argument of the function: fromMaybe :: a -> Maybe a -> a fromMaybe v = \\ case Nothing -> v Just x -> x","title":"Case expressions"},{"location":"development/haskell-style/#let-expressions","text":"Write every let -binding on a new line: isLimitedBy :: Integer -> Natural -> Bool isLimitedBy n limit = let intLimit = toInteger limit in n <= intLimit Put a let before each variable inside a do block.","title":"let expressions"},{"location":"development/haskell-style/#general-recommendations","text":"Try to split code into separate modules. Avoid abusing point-free style. Sometimes code is clearer when not written in point-free style: -- + Good foo :: Int -> a -> Int foo n x = length $ replicate n x -- - Bad foo :: Int -> a -> Int foo = ( length . ) . replicate Code should be compilable with the following ghc options without warnings: -Wall -Wincomplete-uni-patterns -Wincomplete-record-updates -Wcompat -Widentities -Wredundant-constraints -Wmissing-export-lists -Wpartial-fields Enable -fhide-source-paths and -freverse-errors for cleaner compiler output. Use -XApplicativeDo in combination with -XRecordWildCards to prevent position-sensitive errors where possible.","title":"General recommendations"},{"location":"tutorial/quick-start-with-docker/","text":"Quickstart with Docker \u00b6 Installation \u00b6 1. Install docker \u00b6 Note If you have already installed docker, you can skip this step. See Install Docker Engine , and install it for your operating system. Please carefully check that you meet all prerequisites. Confirm that the Docker daemon is running: docker verison Tips On Linux, Docker needs root privileges. You can also run Docker as a non-root user, see Post-installation steps for Linux . 2. Pull image \u00b6 Pull the latest released image of HStreamDB from Docker Hub: docker pull hstreamdb/hstream Start HStreamDB Server \u00b6 1. Create a bridge network \u00b6 The bridge network will enable the containers to communicate as a single cluster while keeping them isolated from external networks. docker network create -d bridge some-hstreamdb-net 2. Start the server \u00b6 docker run -d --network some-hstreamdb-net --name some-hstreamdb hstreamdb/hstream Datas are stored in the VOLUME /data , which can be used with -v /your/host/dir:/data (see use volumes ). Default lisenling port is 6560 , you can expose the port outside of your host (e.g., via -p on docker run ). Warning If you expose the port outside of your host, it will be open to anyone. Connecting via redis-cli \u00b6 docker run -it --rm --network some-hstreamdb-net redis redis-cli -h some-hstreamdb -p 6560 some-hstreamdb:6560> xadd users * name alice age 20 \"1599444243554-0\" some-hstreamdb:6560> xadd users * name bob age 20 \"1599444249940-0\" some-hstreamdb:6560> xrange users - + 1) 1) \"1599444243554-0\" 2) 1) \"name\" 2) \"alice\" 3) \"age\" 4) \"20\" 2) 1) \"1599444249940-0\" 2) 1) \"name\" 2) \"bob\" 3) \"age\" 4) \"20\" Building from source \u00b6 See this document for more details.","title":"Quickstart with Docker"},{"location":"tutorial/quick-start-with-docker/#quickstart-with-docker","text":"","title":"Quickstart with Docker"},{"location":"tutorial/quick-start-with-docker/#installation","text":"","title":"Installation"},{"location":"tutorial/quick-start-with-docker/#1-install-docker","text":"Note If you have already installed docker, you can skip this step. See Install Docker Engine , and install it for your operating system. Please carefully check that you meet all prerequisites. Confirm that the Docker daemon is running: docker verison Tips On Linux, Docker needs root privileges. You can also run Docker as a non-root user, see Post-installation steps for Linux .","title":"1. Install docker"},{"location":"tutorial/quick-start-with-docker/#2-pull-image","text":"Pull the latest released image of HStreamDB from Docker Hub: docker pull hstreamdb/hstream","title":"2. Pull image"},{"location":"tutorial/quick-start-with-docker/#start-hstreamdb-server","text":"","title":"Start HStreamDB Server"},{"location":"tutorial/quick-start-with-docker/#1-create-a-bridge-network","text":"The bridge network will enable the containers to communicate as a single cluster while keeping them isolated from external networks. docker network create -d bridge some-hstreamdb-net","title":"1. Create a bridge network"},{"location":"tutorial/quick-start-with-docker/#2-start-the-server","text":"docker run -d --network some-hstreamdb-net --name some-hstreamdb hstreamdb/hstream Datas are stored in the VOLUME /data , which can be used with -v /your/host/dir:/data (see use volumes ). Default lisenling port is 6560 , you can expose the port outside of your host (e.g., via -p on docker run ). Warning If you expose the port outside of your host, it will be open to anyone.","title":"2. Start the server"},{"location":"tutorial/quick-start-with-docker/#connecting-via-redis-cli","text":"docker run -it --rm --network some-hstreamdb-net redis redis-cli -h some-hstreamdb -p 6560 some-hstreamdb:6560> xadd users * name alice age 20 \"1599444243554-0\" some-hstreamdb:6560> xadd users * name bob age 20 \"1599444249940-0\" some-hstreamdb:6560> xrange users - + 1) 1) \"1599444243554-0\" 2) 1) \"name\" 2) \"alice\" 3) \"age\" 4) \"20\" 2) 1) \"1599444249940-0\" 2) 1) \"name\" 2) \"bob\" 3) \"age\" 4) \"20\"","title":"Connecting via redis-cli"},{"location":"tutorial/quick-start-with-docker/#building-from-source","text":"See this document for more details.","title":"Building from source"}]}